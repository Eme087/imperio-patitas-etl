ARQUITECTURA FAST API.

Nombre del Proyecto: imperio-patitas-etl
________________________________________
1. Estructura de Carpetas y Archivos
Propongo una estructura de proyecto profesional y escalable que separe claramente cada componente, siguiendo los principios que discutimos.
imperio-patitas-etl/
│
├── app/                  # Directorio principal de nuestra aplicación FastAPI
│   ├── __init__.py
│   │
│   ├── api/              # Módulo para los endpoints/rutas de la API
│   │   ├── __init__.py
│   │   └── endpoints.py
│   │
│   ├── core/             # Módulo para la configuración central
│   │   ├── __init__.py
│   │   └── config.py
│   │
│   ├── db/               # Módulo para toda la interacción con la BBDD
│   │   ├── __init__.py
│   │   ├── base.py       # Configuración de SQLAlchemy (engine, session)
│   │   └── models.py     # Definición de las tablas como clases de Python
│   │
│   ├── services/         # Módulo para la lógica de negocio y servicios externos
│   │   ├── __init__.py
│   │   ├── bsale_client.py # Cliente para la API de Bsale
│   │   └── etl_service.py  # Orquestador del proceso ETL
│   │
│   └── main.py           # Punto de entrada principal de la aplicación FastAPI
│
├── .env                  # Archivo para guardar secretos (NO se sube a Git)
├── .gitignore            # Archivo para ignorar archivos y carpetas en Git
└── requirements.txt      # Lista de las librerías de Python necesarias
________________________________________
2. Detalle de Cada Componente
.env (Archivo de Entorno)
Contendrá nuestras variables secretas. Simple y directo.
Ini, TOML
# Configuración Base de Datos
DATABASE_URL="mysql+pymysql://usuario:contraseña@host_de_cloud_sql/nombre_bbdd"

# Credenciales de Bsale
BSALE_API_TOKEN="tu_token_secreto_de_bsale"
app/core/config.py
•	Propósito: Cargar las variables del archivo .env de forma segura y validada.
•	Contenido: Una clase Settings que usa Pydantic. Esto asegura que si falta una variable, la aplicación falle al iniciar (lo cual es bueno).
Python
# app/core/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str
    BSALE_API_TOKEN: str

    class Config:
        env_file = ".env"

settings = Settings()
app/db/models.py
•	Propósito: Definir la estructura de nuestras tablas de MySQL como clases de Python (Modelos de SQLAlchemy). Es la aplicación directa de nuestro esquema de BBDD.
•	Contenido: Clases como Cliente, Producto, Variante, etc., que mapean a cada tabla.
Python
# app/db/models.py
from sqlalchemy import Column, Integer, String, DECIMAL, DATETIME, ForeignKey
from sqlalchemy.dialects.mysql import TINYINT # Corregido: TINYINT se importa desde el dialecto de MySQL
from sqlalchemy.orm import relationship
from .base import Base # Importaremos Base desde base.py

class Cliente(Base):
    __tablename__ = 'clientes'
    id_bsale = Column(Integer, primary_key=True)
    nombre = Column(String(255))
    # ... resto de las columnas ...

# ... resto de las clases para Producto, Variante, DocumentoVenta, etc. ...
app/db/base.py
•	Propósito: Configurar la conexión con la base de datos (el "motor" o engine) y crear un gestor de sesiones.
•	Contenido: El código estándar de SQLAlchemy para conectarse a la BBDD definida en config.py y una Base declarativa para los modelos.
app/services/bsale_client.py
•	Propósito: Encapsular TODA la comunicación con la API de Bsale. Principio de Responsabilidad Única (SRP) en acción.
•	Contenido: Una clase BsaleClient con métodos claros.
o	Un método privado _fetch_all_pages(endpoint) que contendrá la lógica del bucle para manejar la paginación. Principio DRY para no repetir esta lógica.
o	Métodos públicos como get_products(), get_variants(), get_documents_by_date(date) que usarán _fetch_all_pages para devolver los datos completos.
app/services/etl_service.py
•	Propósito: Orquestar todo el flujo ETL. Es el cerebro que llama a los otros servicios. Principio de Inversión de Dependencias (DIP), ya que depende de las "interfaces" de los otros módulos, no de sus detalles.
•	Contenido: Funciones que definen cada tarea.
o	sync_full_products(db_session): Llama a bsale_client.get_products(), transforma los datos al formato de los modelos de db/models.py y los guarda en la base de datos.
o	sync_daily_sales(db_session, date): Obtiene las ventas del día, las transforma y las guarda.
app/api/endpoints.py
•	Propósito: Exponer los endpoints HTTP que activarán nuestro ETL.
•	Contenido: Un APIRouter de FastAPI con las rutas.
Python
# app/api/endpoints.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
# ... importaciones de etl_service y db ...

router = APIRouter()

@router.post("/etl/run-full-sync", tags=["ETL"])
def run_full_sync(db: Session = Depends(get_db)):
    # Llama a las funciones en etl_service para una sincronización completa
    # ej: etl_service.sync_full_products(db)
    #     etl_service.sync_full_clients(db)
    return {"status": "Full sync started"}

@router.post("/etl/run-daily-sync", tags=["ETL"])
def run_daily_sync(db: Session = Depends(get_db)):
    # Llama a etl_service.sync_daily_sales(db, date.today())
    return {"status": "Daily sync started"}

@router.get("/health", tags=["Monitoring"])
def health_check():
    return {"status": "ok"}
app/main.py
•	Propósito: Crear la instancia principal de la aplicación FastAPI y registrar las rutas.
•	Contenido: Un archivo muy corto y limpio.
Python
# app/main.py
from fastapi import FastAPI
from .api import endpoints

app = FastAPI(title="ETL Service for Imperio Patitas")

app.include_router(endpoints.router)
________________________________________
3. Flujo de Ejecución (Ejemplo: Sincronización Diaria)
1.	Un servicio externo (como Google Cloud Scheduler) hace una llamada POST a la URL de nuestra aplicación, al endpoint /etl/run-daily-sync.
2.	main.py dirige la petición al router en api/endpoints.py.
3.	El endpoint run_daily_sync se activa. Usando la inyección de dependencias de FastAPI, obtiene una sesión de base de datos (db).
4.	Llama a la función sync_daily_sales dentro de services/etl_service.py, pasándole la sesión db.
5.	etl_service.py le pide al services/bsale_client.py que traiga los documentos del día.
6.	bsale_client.py realiza las llamadas necesarias a la API de Bsale, manejando la paginación.
7.	Una vez que etl_service.py recibe los datos, los transforma para que coincidan con los modelos definidos en db/models.py.
8.	Finalmente, usa la sesión db para guardar los nuevos registros en tu base de datos Cloud SQL (MySQL).
9.	El endpoint responde con un mensaje de éxito.
Este es nuestro plano final y detallado. Cada pieza tiene su lugar, su propósito, y sigue los principios de diseño que garantizan un código limpio y mantenible.
Ahora sí, estamos listos para tomar la primera pieza, el archivo .env y el app/core/config.py, y empezar a construir.
